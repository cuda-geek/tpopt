<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Pragmatic optimization in modern programming</title>

        <meta name="description" content="Pragmatic optimization in modern programming">
        <meta name="author" content="geek">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/beige.css" id="theme">
        <link rel="stylesheet" href="css/customization.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- <link rel="shortcut icon" href="images/ico/favicon.ico"> -->

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Pragmatic optimization</h1>
          <h2>In modern programming</h2>
          <h3>Mastering compiler optimizations</h3>
          <p>
            <small>Created by
              <a href="https://github.com/cuda-geek">Marina (geek) Kolpakova</a>
              for
              <a href="unn.ru">UNN</a>
              / 2015-2016
            </small>
          </p>
        </section>

        <section>
          <h2>Course Topics</h2>
          <ul>
            <li><strong>Pragmatics</strong>
              <ul>
                <li>Ordering optimization approaches</li>
                <li>Demystifying a compiler</li>
                <li style="margin-bottom: 20px;"><b>Mastering compiler optimizations</b></li>
              </ul>
            </li>
<!--             <li><strong>Computer Architectures</strong>
              <ul>
                <li>Modern architecture families</li>
                <li>Cache organization</li>
                <li style="margin-bottom: 20px;">Instruction scheduling</li>
              </ul>
            </li> -->
<!--             <li><strong>Advanced capabilities</strong>
              <ul>
                <li>SIMD extensions</li>
                <li>Specific co-processors</li>
              </ul>
            </li> -->
          </ul>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <li>Constant folding</li>
            <li>Hoisting loop invariant code</li>
            <li>Scalarization</li>
            <li>Loop unswitching</li>
            <li>Loop peeling and sentinels</li>
            <li>Strength reduction</li>
            <li>Loop-induction variable elimination</li>
            <li>Auto-vectorization</li>
            <li>Function body inlining</li>
            <li>Built-in detection</li>
            <li>Case study</li>
          </ul>
        </section>

        <section>
          <h2>Constant folding</h2>
          <blockquote>evaluates expressions from constants in compile time</blockquote>
          <p>It is one of the simplest and most widely used compiler transformations. Expressions could be quite
          complicated, but absence of any kind of side effects is always to be considered.</p>
          <pre><code class="cpp">double b = exp(sqrt(M_PI/2));</code></pre>
          <p></p>
          <pre><code class="armacm">  fldd  d17, .L5
// other code
  .L5:
    .word 2911864813
    .word 1074529267</code></pre>
          <p>May be performed in global as well as local scope.<br> Applicable to any code pattern.</p>
        </section>

        <section>
          <section>
            <h2>Hoisting Loop Invariant Code</h2>
            <blockquote>The goal of <b>hoisting</b> &mdash; also called <b>loop-invariant code motion</b> &mdash; is to avoid recomputing
            loop-invariant code each time through the body of a loop.</blockquote>
                    <pre><code class="cpp">void scale(double* x, double* y, int len)
{
  for (int i = 0; i &lt; len; i++)
    y[i] = x[i] * exp(sqrt(M_PI/2));
}</code></pre>
            <p>... is the same as...</p>
            <pre><code class="cpp">void scale(double* x, double *y, int len)
{
  double factor = exp(sqrt(M_PI/2));
  for (int i = 0; i &lt; len; i++)
    y[i] = x[i] * factor;
}</code></pre>
          </section>
          <section>
            <h2>Hoisting Loop Invariant Code</h2>
            <pre style="font-size: 0.95em;" class="console">$ gcc -march=armv7-a  -mthumb -O1 -S -o 1.s\
-mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</pre>
           <table class="simple" style="font-size:0.95em;">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code class="armacm">  fldd  d17, .L5
  .L3:
    fldmiad r3!, {d16}
    fmuld d16, d16, d17
    fstmiad r1!, {d16}
    cmp r3, r0
    bne .L3
  .L1:
    bx  lr
  .L5:
    .word 2911864813
    .word 1074529267</code></pre>
                  </td>
                  <td>
                    <pre><code class="armasm">  fldd  d17, .L11
  .L9:
    fldmiad r3!, {d16}
    fmuld d16, d16, d17
    fstmiad r1!, {d16}
    cmp r3, r0
    bne .L9
  .L7:
    bx  lr
  .L11:
    .word 2911864813
    .word 1074529267</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </section>

          <section>
            <h2>Hoisting non-constants</h2>
            <p>Let's make expression variable</p>
            <pre><code class="cpp">void scale(double* x, double* y, int len)
{
  for (int i = 0; i &lt; len; i++)
    y[i] = x[i] * exp(sqrt((double)len)/2.));
}</code></pre>
            <pre><code class="cpp">void scale(double* x, double *y, int len)
{
  double factor = exp(sqrt((double)len)/2.));
  for (int i = 0; i &lt; len; i++)
    y[i] = x[i] * factor;
}</code></pre>
            <pre style="font-size: 0.95em;" class="console">$ gcc -march=armv7-a  -mthumb -O1 -S -o 1.s\
-mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</pre>
          </section>

          <section>
            <h2>Hoisting non-constants</h2>
           <table class="simple" style="font-size:0.95em;">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre><code style="max-height: 490px;" class="armacm">  fmsr  s15, r2 @ int
  fsitod  d9, s15
  fsqrtd  d9, d9
.L4:
  fldmiad r6!, {d8}
  fcpyd d16, d9
  fcmpd d9, d9
  fmstat
  beq .L3
  fmsr  s15, r7 @ int
  fsitod  d16, s15
  fmrrd r0, r1, d16
  bl  sqrt(PLT)
  fmdrr d16, r0, r1
.L3:
  fmuld d8, d8, d16
  fstmiad r5!, {d8}
  adds  r4, r4, #1
  cmp r4, r7
  bne .L4</code></pre>
                  </td>
                  <td>
                    <pre><code style="max-height: 490px;" class="armasm">  fmsr  s15, r2 @ int
  fsitod  d17, s15
  fsqrtd  d17, d17
  fcmpd d17, d17
  fmstat
  beq .L9
  fsitod  d16, s15
  fmrrd r0, r1, d16
  bl  sqrt(PLT)
  fmdrr d17, r0, r1
.L9:
  mov r3, r5
  mov r1, r4
  add r0, r5, r6, lsl #3
.L11:
  fldmiad r3!, {d16}
  fmuld d16, d16, d17
  fstmiad r1!, {d16}
  cmp r3, r0
  bne .L11</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <strong>Compiler isn't sure that floating point flags aren't affected!</strong>
          </section>
        </section>

        <section>
          <h2>Scalarization</h2>
          <blockquote><b>Scalarization</b> replaces branchy code with a branchless analogy</blockquote>
          Usually it is performed on a branches inside a loop body to allow further optimization. Machine-independent, local.
         <table>
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td style="padding-top: 0; padding-bottom: 0">
            <pre><code class="cpp">int branchy(int i)
{
  if (i &gt; 4 && i &lt; 42) return 1;
  return 0;
}</code></pre>
                </td>
                <td style="padding-top: 0; padding-bottom: 0">
              <pre><code class="cpp">int branchless(int i)
{
  return (((unsigned)i) - 5 &lt; 36);
}
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <pre style="font-size: 0.95em; margin-bottom: 0px; margin-top: 0px;" class="console">$ gcc -march=armv8-a+simd -O3 1.c -S -o 1.s</pre>
          <table>
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td  style="padding-top: 0; padding-bottom: 0">
          <pre><code class="asm">branchy:
  sub w0, w0, #5
  cmp w0, 36
  cset  w0, ls
  ret</code></pre>
                </td>
                <td  style="padding-top: 0; padding-bottom: 0">
<pre><code class="asm">branchless:
  sub w0, w0, #5
  cmp w0, 36
  cset  w0, ls
  ret</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <section>
          <section>
            <h2>Loop unswitching</h2>
            <blockquote>Moves loop-invariant conditionals or switches which are independent of the loop index out of
            the loop. Increases <abbr title="instruction level parallelism">ILP</abbr>, enables further optimizations.</blockquote>
            <table class="simple">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="width: 50%;">
                   <pre><code class="cpp">for (int i = 0; i &lt; len; i++)
{
 if (a > 32)
  arr[i] = a;
 else
  arr[i] = 42;
}
</code></pre> </td>
                  <td style="width: 50%;">
                   <pre><code class="cpp">int i = 0;
if (a > 32)
 for (; i &lt; len; i++)
  arr[i] = a;
else
 for (; i &lt; len; i++)
  arr[i] = 42;</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <pre style="font-size: 0.95em;" class="console">$ gcc -march=armv8-a+simd -O3 -S -o 1.s \
-fno-tree-vectorize 1.c</pre>
            <small>auto-vectorization is disabled just to make example readable.</small>
          </section>

          <section>
            <h2>Loop unswitching</h2>
                   <pre><code style="max-height: 720px;" class="armasm"> cmp w1, wzr
 ble .L1
 cmp w2, 32
 bgt .L6
 mov x2, 0
 mov w3, 42
.L4:
 str w3,[x0,x2,lsl 2]
 add x2, x2, 1
 cmp w1, w2
 bgt .L4
.L1:
  ret
L6:
 mov x3, 0
.L3:
 str w2,[x0,x3,lsl 2]
 add x3, x3, 1
 cmp w1, w3
 bgt .L3
 ret</code></pre>
          </section>

          <section>
            <h2>Loop peeling</h2>
            <blockquote><b>Loop peeling</b> takes out of the loop and executes separately a small number of iterations
            from the beginning or/and the end of a loop, which eliminates if-statements.</blockquote>
            Can be done by a compiler under high optimization levels.
            <table class="simple" style="font-size:0.85em;">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="padding:0; width:50%">
                   <pre><code class="cpp">for(int i=0; i&lt;len; i++)
{
  if (i == 0)
    b[i] = a[i+1];
  else if(i == len-1 )
    b[i] = a[i-1];
  else
    b[i] = a[i+1]+a[i-1];
}</code></pre>
                  </td>
                  <td>
                   <pre><code class="cpp">b[0] = a[0];

for(int i=0; i&lt;len; i++)
  [i] = a[i+1]+a[i-1];

b[len-1] = a[len-1];



</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <small>For the example below both tested compilers: gcc 4.9 and clang 3.5
            <strong>won't</strong> perform this optimization. Make sure that a compiler was able to apply optimization
            to such a code pattern or do it manually.</small>
          </section>

          <section>
            <h2>Advanced unswitching: Sentinels</h2>
            <blockquote><b>Sentinels</b> are special dummy values placed in a data structure which are added to simplify
            the logic of handling boundary conditions (in particular, handling of loop-exit tests
            or elimination out-of-bound checks).</blockquote>

            <p><strong>This optimization cannot be performed by the compiler <br/>because require changes in use of
            data structures</strong></p>
          </section>

          <section>
            <h2>Advanced unswitching: Sentinels</h2>
            <p>Let's assume that array <strong><code>a</code></strong> contains two extra elements:
            one &mdash; at the left <strong><code>a[-1]</code></strong>,
             and one &mdash; at the right <strong><code>a[N]</code></strong>. With such assumptions the code can be
             rewritten as follows.</p>

            <table class="simple" style="font-size:0.85em;">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="padding:0;width:50%;">
                   <pre><code class="cpp">for(int i=0; i&lt;len; i++)
{
  if (i == 0)
    b[i] = a[i+1];
  else if(i == len-1 )
    b[i] = a[i-1];
  else
    b[i] = a[i+1]+a[i-1];
}</code></pre>
                  </td>
                  <td>
                   <pre><code class="cpp">// setup boundaries
a[-1]  = 0;
a[len] = 0;

for (int i=0; i&lt;len; i++)
  [i] = a[i+1] + a[i-1];



</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>

          </section>
        </section>


        <section>
          <section>
            <h2>Strength Reduction</h2>
            <blockquote>replaces complex expressions with a simpler analogy</blockquote>
            <table>
              <colgroup>
                <col style="width: 50%;"/>
                <col style="width: 50%;"/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre style="font-size: 0.80em;"><code class="cpp" data-trim data-noescape>double usePow(double x)
{
  return pow(x, 2.);
}</code></pre>
                  </td>
                  <td>
                    <pre style="font-size: 0.80em;"><code class="cpp" data-trim data-noescape>float usePowf(float x)
{
  return powf(x, 2.f);
}</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>
              <strong>Machine-independent transformation in most cases.</strong><br>
              It may be machine-dependent in case if it relies on a specific feature set,
              implemented in the HW (e.g. <i>built-in detection</i>)
            </p>
          </section>

          <section>
            <h2>Strength Reduction</h2>
            <pre style="font-size: 0.95em;" class="console"><span>$ gcc -march=armv7-a -mthumb -O3 -S -o 1.s \
> -mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</span></pre>
            <table>
              <colgroup>
                <col style="width: 50%;"/>
                <col style="width: 50%;"/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <pre style="font-size: 0.9em;"><code class="armasm" data-trim data-noescape>usePow:
 <abbr title="Puts a pair of integer registers (that holds function parameters) into one double precision register">fmdrr</abbr> d16, r0, r1
 <abbr title="Double precision multiply">fmuld</abbr> d16, d16, d16
 <abbr title="Puts one double precision register into a pair of integer registers (to pass function result)">fmrrd</abbr> r0, r1, d16
 <abbr title="Branch to the link register == subroutine return">bx</abbr>  lr
</code></pre>
                  </td>
                  <td>
                    <pre style="font-size: 0.9em;"><code class="armasm" data-trim data-noescape>usePowf:
 fmsr  s15, r0
 fmuls s15, s15, s15
 fmrs  r0, s15
 bx  lr</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>Usually it is performed in a local scope<br> for a dependency chain.</p>
          </section>

          <section>
            <h2>Strength Reduction (advanced case)</h2>
            <pre style="font-size: 0.9em;"><code class="cpp" data-trim data-noescape>float useManyPowf(float a, float b, float c,
         float d, float e, float f, float x)
{
  return
      a * powf(x, 5.f) +
      b * powf(x, 4.f) +
      c * powf(x, 3.f) +
      d * powf(x, 2.f) +
      e * x            + f;
}</code></pre>
            <pre style="font-size: 0.95em;" class="console"><span>$ gcc -march=armv7-a -mthumb -O3 -S -o 1.s \
> -mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</span></pre>
          </section>
          <section>
            <h2>Strength Reduction (advanced)</h2>
            <table style="width: 100%" class="simple">
              <colgroup>
                <col style="width: 50%;"/>
                <col style="width: 50%;"/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="width: 50%;">
                    <pre><code class="armasm">useManyPowf:
  push  {r3, lr}
  flds  s17, [sp, #56]
  fmsr  s24, r1
  movs  r1, #0
  fmsr  s22, r0
  movt  r1, 16544
  fmrs  r0, s17
  fmsr  s21, r2
  fmsr  s20, r3
  flds  s19, [sp, #48]
  flds  s18, [sp, #52]
  bl  powf(PLT)
  mov r1, #1082130432
  fmsr  s23, r0
  fmrs  r0, s17
  bl  powf(PLT)
</code></pre>
                  </td>
                  <td>
                    <pre><code class="armasm">  movs  r1, #0
  movt  r1, 16448
  fmsr  s16, r0
  fmrs  r0, s17
  bl  powf(PLT)
  fmuls s16, s16, s24
  vfma.f32  s16, s23, s22
  fmsr  s15, r0
  vfma.f32  s16, s15, s21
  fmuls s15, s17, s17
  vfma.f32  s16, s20, s15
  vfma.f32  s16, s19, s17
  fadds s15, s16, s18
  fldmfdd sp!, {d8-d12}
  fmrs  r0, s15
  pop {r3, pc}</code></pre>
                  </td>
                </tr>
              </tbody>
            </table>

            Compiler was able just partly reduce the complexity and generate <strong><code>vfma</code></strong> there it is possible
          </section>

          <section>
            <h2>Strength Reduction (manual)</h2>
            <p>Let's further reduce latency by applying Horner rule.</p>
            <pre  style="font-size: 0.7em;"><code class="cpp">float applyHornerf(float a, float b, float c,
                   float d, float e, float f, float x)
{
  return ((((a * x + b) * x + c) * x + d) * x + e) * x + f;
}</code></pre>
            <pre style="font-size: 0.95em;" class="console"><span>$ gcc -march=armv7-a -mthumb -O3 -S -o 1.s \
> -mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</span></pre>
            <p>Compiler is not capable of this optimization because it doesn't produce exact result with the original formula</p>
          </section>
          <section>
            <h2>Strength Reduction (manual)</h2>
            <pre><code class="armasm">applyHornerf:
  flds  s15, [sp, #8]
  fmsr  s11, r0
  fmsr  s12, r1
  flds  s14, [sp]
  vfma.f32  s12, s11, s15
  fmsr  s11, r2
  flds  s13, [sp, #4]
  vfma.f32  s11, s12, s15
  fcpys s12, s11
  fmsr  s11, r3
  vfma.f32  s11, s12, s15
  vfma.f32  s14, s11, s15
  vfma.f32  s13, s14, s15
  fmrs  r0, s13
  bx  lr</code></pre>
          </section>
        </section>

        <section>
          <section>
          <h2>Loop-induction variable elimination</h2>
          <blockquote>In most cases compiler is able to replace<br><i>address arithmetics</i> with <i>pointer arithmetics</i>.</blockquote>
                  <pre><code class="cpp">void function(int* arr, int len)
{
  for (int i = 0; i &lt; len; i++)
    arr[i] = 1;
}</code></pre>
                  <pre><code class="cpp">void function(int* arr, int len)
{
  for (int* p = arr; p &lt; arr + len; p++)
      *p = 1;
}</code></pre>
          <pre style="font-size: 0.95em;" class="console"><span>$ gcc -march=armv7-a -mthumb -O1 -S -o 1.s \
> -mfpu=neon-vfpv4 -mfloat-abi=softfp 1.c</span></pre>
          </section>

          <section>
          <h2>Loop-induction variable elimination</h2>
          <table class="simple">
            <colgroup>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td style="padding:0; width: 50%;">
                  <pre><code class="armacm">  cmp r1, #0
  ble .L1
  mov r3,r0
  add r0,r0,r1,lsl #2
  movs  r2, #1
.L3:
  str r2, [r3], #4
  cmp r3, r0
  bne .L3
.L1:
  bx  lr</code></pre>
                </td>
                <td  style="padding:0;" >
                  <pre><code class="armasm">
  add r1,r0,r1,lsl #2
  cmp r0, r1
  bcs .L5
  movs  r3, #1
.L8:
  str r3, [r0], #4
  cmp r1, r0
  bhi .L8
.L5:
  bx  lr</code></pre>
                </td>
              </tr>
            </tbody>
            </table>
          <blockquote>Most hand-written <b>pointer optimizations</b> do not make sense with usage optimization levels
            higher than O0.</blockquote>
          </section>
        </section>

        <section>
          <section>
            <h2>Auto-vectorization</h2>
            <blockquote><b>Auto-vectorization</b> is machine code generation<br> that takes an advantage of vector instructions.</blockquote>
            <ul>
              <li>Most of all modern architectures have vector extensions as a co-processor or as dedicated pipes
                <ul>
                  <li>MMX, SSE, SSE2, SSE4, AVX, AVX-512</li>
                  <li>AltiVec, VSX</li>
                  <li>ASIMD (NEON), MSA</li>
                </ul>
              </li>
              <li>Enabled by inlining, unrolling, fusion, software pipelining, inter-procedural optimization, and
              other machine independent transformations.</li>
            </ul>
          </section>

          <section>
            <h2>Auto-vectorization</h2>
            <pre><code class="cpp">void vectorizeMe(float *a, float *b, int len)
{
  int i;
  for (i = 0; i &lt; len; i++)
    a[i] += b[i];
}</code></pre>
            <pre style="font-size: 0.95em;" class="console"><span>$ gcc -march=armv7-a -mthumb -O3 -S -o 1.s \
> -mfpu=neon-vfpv4 -mfloat-abi=softfp \
> -fopt-info-missed 1.c</span></pre>
            <p>But, NEON does not support full IEEE 754,<br>so gcc cannot vectorize the loop, what it told us</p>
            <pre style="font-size: 0.95em;" class="console"><span>1.c:64:3: note: not vectorized:
relevant stmt not supported:_13 =_9+_12;</span></pre>
          </section>

          <section>
            <h2>Auto-vectorization</h2>
             Here is a generated assembly
            <pre><code class="armasm">.L3:
  fldmias r1!, {s14}
  flds  s15, [r0]
  fadds s15, s15, s14
  fstmias r0!, {s15}
  cmp r0, r2
  bne .L3</code></pre>
            <p>But armv8-a does support, let's check it!</p>
            <pre style="font-size: 0.95em;" class="console">$ gcc -march=armv8-a+simd -O3 -S -o 1.s \
> -fopt-info-all 1.c</pre>
            and... Here we are!
            <pre style="font-size: 0.95em;" class="console">1.c:64:3: note: loop vectorized</pre>
          </section>

          <section>
            <h2>Auto-vectorization</h2>
            Here is a generated assembly and full optimizer's report
            <pre><code class="armasm">.L6:
  ldr q1, [x3],16
  add w6, w6, 1
  ldr q0, [x7],16
  cmp w6, w4
  fadd  v0.4s, v0.4s, v1.4s
  str q0, [x8],16
  bcc .L6</code></pre>

            <pre  style="font-size: 0.54em;" class="console"><span>
1.c:66:3: note: loop <b>vectorized</b>
1.c:66:3: note: loop <b>versioned</b> for vectorization because of possible aliasing
1.c:66:3: note: loop <b>peeled</b> for vectorization to enhance alignment
1.c:66:3: note: loop with 3 iterations completely <b>unrolled</b>
1.c:61:6: note: loop with 3 iterations completely <b>unrolled</b>
</span></pre>
            <strong>Compiler versions the loop to allow optimized paths<br/>in case of aligned and non-aliasing pointers</strong>
          </section>

          <section>
            <h2>keywords</h2>
            Let's follow the advice to put some keywords
            <pre><code class="cpp">void vectorizeMe(float* __restrict a_, float* __restrict b_, int len)
{
  float *a=__builtin_assume_aligned(a_, 16);
  float *b=__builtin_assume_aligned(b_, 16);
  for (int i = 0; i &lt; len; i++)
    a[i] += b[i];
}</code></pre>
            Optimizer's report shrinks.
            <pre style="font-size: 0.7em;" class="console" >
1.c:66:3: note: loop vectorized
1.c:66:3: note: loop with 3 iterations completely unrolled</pre>
            <strong><b><code>__restrict</code></b> and <b><code>__builtin_assume_aligned</code></b> keywords only eliminate some loop
            versioning, but are not very useful from the performance perspective</strong>
          </section>
        </section>

        <section>
          <section>
            <h2>Function body inlining</h2>
            <blockquote>Replaces functional call to function body itself.</blockquote>
            <pre><code class="cpp">int square(int x) { return x*x; }

for (int i = 0; i &lt; len; i++)
  arr[i] = square(i);</code></pre>
            <p>Becomes</p>
            <pre><code class="cpp">for (int i = 0; i &lt; len; i++)
    arr[i] = i*i;</code></pre>
            <p><strong>Enables all further optimizations.</strong><br>
            Machine-independent, interprocedural.</p>
          </section>

          <section>
            <h2>Function body inlining</h2>
            <pre class="console" style="font-size: 0.95em;">gcc -march=armv8-a+nosimd -O3 -S -o 1.s 1.c</pre>
            <pre><code class="armasm" data-trim data-noescape>.L2:
  add x2, x4, :lo12:.LANCHOR0
  mov x1, 34464
  mul w3, w0, w0
  <abbr title="Move 16-bit immediate into register, keeping other bits unchanged.">movk</abbr>  x1, 0x1, lsl 16
  str w3, [x2,x0,lsl 2]
  add x0, x0, 1
  cmp x0, x1
  bne .L2</code></pre>
            <p>Let's compile the code with vector extension enabled</p>
            <pre style="font-size: 0.95em;" class="console">-march=armv8-a+simd</pre>
          </section>

          <section>
            <h2>Function body inlining</h2>
            <pre><code class="armasm">  add x0, x0, :lo12:.LANCHOR0
  movi  v2.4s, 0x4
  ldr q0, [x1]
  add x1, x0, 397312
  add x1, x1, 2688
.L2:
  mul v1.4s, v0.4s, v0.4s
  add v0.4s, v0.4s, v2.4s
  str q1, [x0],16
  cmp x0, x1
  bne .L2</code></pre>
            <p>Auto-vectorization is enabled because of possibility<br> to inline function call inside a loop.</p>
          </section>
        </section>

        <section>

          <section>
            <h2>Built-in detection</h2>
            <p>Compiler automatically uses the library functions <code>memset</code> and <code>memcpy</code>
            to initialize and copy memory blocks</p>
            <pre style="font-size: 0.7em;"><code style="max-height:720px;" data-trim class="cpp" >static char a[100000];
static char b[100000];
static int at(int idx, char val)
{
 if (idx&gt;=0 &amp;&amp; idx&lt;100000)
  a[idx] = val;
}

int main()
{
 for (int i=0; i&lt;100000; ++i) a[i]=42;
 for (int i=0; i&lt;100000; ++i) at(i,-1);
 for (int i=0; i&lt;100000; ++i) b[i] = a[i];
}</code></pre>
          </section>

          <section>
            <h2>Filling/copying memory blocks</h2>
            Compiler knows what you mean
            <pre style="font-size: 0.55em;"><code style="max-height:720px;" class="x86asm">main:
.LFB1:
  .cfi_startproc
  subq  $8, %rsp
  .cfi_def_cfa_offset 16
  movl  $100000, %edx
  movl  $42, %esi
  movl  $a, %edi
  call  memset
  movl  $100000, %edx
  movl  $255, %esi
  movl  $a, %edi
  call  memset
  movl  $100000, %edx
  movl  $a, %esi
  movl  $b, %edi
  call  memcpy
  addq  $8, %rsp
  .cfi_def_cfa_offset 8
  ret</code></pre>
          </section>

          <section>
            <h2>Filling/copying memory blocks</h2>
            The same picture, if the code is compiled for ARM target
            <pre style="font-size: 0.54em;"><code style="max-height:720px;" class="x86asm">main:
  ldr r3, .L3
  mov r1, #42
  stmfd sp!, {r4, lr}
  add r3, pc, r3
  movw  r4, #34464
  movt  r4, 1
  mov r0, r3
  mov r2, r4
  bl  memset(PLT)
  mov r2, r4
  mov r1, #255
  bl  memset(PLT)
  mov r2, r4
  mov r3, r0
  ldr r0, .L3+4
  mov r1, r3
  add r0, pc, r0
  add r0, r0, #1792
  bl  memcpy(PLT)
  ldmfd sp!, {r4, pc}</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Case Study: floating point</h2>
            <pre style="font-size: 0.7em;"><code class="cpp">double power( double d, unsigned n)
{
  double x = 1.0;
  for (unsigned j = 1; j&lt;=n; j++, x *= d) ;
  return x;
}
int main ()
{
  double a = 1./0x80000000U, sum = 0.0;
  for (unsigned i=1; i&lt;= 0x80000000U; i++)
    sum += power( i*a, i % 8);
  printf ("sum = %g\n", sum);
}</code></pre>
            <small style="float:right;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-dp-c">flags-dp.c</a>
            </small>
          </section>

          <section>
            <h2>Case Study: floating point</h2>
            <ol style="width:90%">
              <li>Compile it <b>without</b> optimization
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O0 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m24.550s</span></pre></li>
              <li>Compile it with <b>O1</b>: <b>~3.26 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O1 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m7.529s</span></pre></li>
            </ol>
          </section>

          <section>
            <h2>Case Study: floating point</h2>
            <ol start="3" style="width:90%">
              <li>Compile it with <b>O2</b>: <b>~1.24 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O2 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m6.069s</span></pre></li>
              <li>Compile it with <b>O3</b>:  <b>~1.00 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O3 flags-dp.c -o flags-dp
$ time ./flags-dp
sum = 7.29569e+08
real  0m6.067s</span></pre></li>
            </ol>
            <p><b>Total speedup is ~4.05</b></p>
          </section>
        </section>

        <section>
          <section>
            <h2>Case Study: integer</h2>
            <pre style="font-size: 0.7em;"><code class="cpp">int power( int d, unsigned n)
{
  int x = 1;
  for (unsigned j = 1; j&lt;=n; j++, x*=d) ;
  return x;
}
int main ()
{
  int64_t sum = 0;
  for (unsigned i=1; i&lt;0x80000000U; i++)
    sum += power( i, i % 8);
  printf ("sum = %ld\n", sum);
}</code></pre>
            <small style="float:right;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-c">flags.c</a>
            </small>
          </section>

          <section>
            <h2>Case Study: integer</h2>
            <ol style="width:90%">
              <li>Compile it <b>without</b> optimization
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O0 flags.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m18.750s</span></pre></li>
              <li>Compile it with <b>O1</b>: <b>~2.64 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O1 flag.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m7.092s</span></pre></li>
            </ol>
          </section>

          <section>
            <h2>Case study: integer</h2>
            <ol start="3" style="width:90%">
              <li>Compile it with <b>O2</b>:<b>~0.97 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O2 flags.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m7.300s</span></pre></li>
              <li>Compile it with <b>O3</b>:  <b>~1.00 speedup</b>
                <pre style="font-size: 0.8em;" class="console"><span>$ gcc -std=c99 -Wall -O3 flags.c -o flags
$ time ./flags
sum = 288231861405089791
real  0m7.082s</span></pre></li>
            </ol>
            <h3>What there is no improvement?</h3>
          </section>

          <section>
            <h2>Example: integer</h2>
            <table style="width:100%; font-size:0.8em;" class="simple">
              <colgroup>
                <col style="width:33%;"/>
                <col style="width:33%;"/>
                <col style="width:33%;"/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="border-right: 3px double #F0E7D5;">-O1
                    <pre><code class="x86asm" style="max-height: 720px;">  movl  $1, %r8d
  movl  $0, %edx
.L9:
  movl  %r8d, %edi
  movl  %r8d, %esi
  andl  $7, %esi
  je  .L10
  movl  $1, %ecx
  movl  $1, %eax
.L8:                @
  addl  $1, %eax    @
  imull %edi, %ecx  @
  cmpl  %eax, %esi  @
  jae .L8
  jmp .L7
.L10:
  movl  $1, %ecx
.L7:
  movslq  %ecx, %rcx
  addq  %rcx, %rdx
  addl  $1, %r8d
  jns .L9
  @ printing is here</code></pre>
                  </td>
                  <td>-O2
                    <pre><code class="x86asm">  movl    $1, %esi
    movl    $1, %r8d
    xorl    %edx, %edx
    .p2align 4,,10
    .p2align 3
.L10:
    movl    %r8d, %edi
    andl    $7, %edi
    je  .L11
    movl    $1, %ecx
    movl    $1, %eax
    .p2align 4,,10
    .p2align 3
.L9:
    addl    $1, %eax
    imull   %esi, %ecx
    cmpl    %eax, %edi
    jae .L9
    movslq  %ecx, %rcx</code></pre>
                  </td>
                  <td><br/>
                    <pre><code class="x86asm">.L8:
    addl    $1, %r8d
    addq    %rcx, %rdx
    testl   %r8d, %r8d
    movl    %r8d, %esi
    jns .L10
    subq    $8, %rsp
    @ printing is here
    ret
.L11:
    movl    $1, %ecx
    jmp .L8</code></pre>
                  <br>
                  <h3>Compiler overdone with branch twiddling!</h3>
                  </td>
                </tr>
              </tbody>
            </table>
          </section>

        </section>
        <section>

          <section>
            <h2>Helping a compiler</h2>
            <blockquote>Compiler usually applies optimization to the inner loops. In this example number of iterations in the inner
            loop depends on a value of an induction variable of the outer loop.</blockquote>
            <p> Let's help the compiler (
            <small style="vertical-align:middle;">
              <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-dp-tuned-c">flags-dp-tuned.c</a>
            </small>)</p>
          </section>
          <section>
            <h2>Helping a compiler</h2>
            <pre><code class="cpp">/*power function is not changed*/
int main ()
{
  double a = 1./0x80000000U, s = -1.;
  for (double i=0; i&lt;=0x80000000U-8; i += 8)
  {
    s+=power((i+0)*a,0);s+=power((i+1)*a,1);
    s+=power((i+2)*a,2);s+=power((i+3)*a,3);
    s+=power((i+4)*a,4);s+=power((i+5)*a,5);
    s+=power((i+6)*a,6);s+=power((i+7)*a,7);
  }
  printf ("sum = %g\n", s);
}</code></pre>
            <pre style="font-size: 0.7em;" class="console"><span>$ gcc -std=c99 -Wall -O3 flags-dp-tuned.c -o flags-dp-tuned
$ time ./flags-dp-tuned
sum = 7.29569e+08
real  0m2.448s</span></pre>
            <b>Speedup is ~2.48x.</b>
          </section>

          <section>
            <h2>Helping a compiler</h2>
            Let's try it for integers (
              <small style="vertical-align:middle;">
                <a href="https://gist.github.com/cuda-geek/2be305eb6aa99dc55aa6#file-test-flags-tuned-c">flags-tuned.c</a>
              </small>)

            <pre style="font-size: 0.5em;"><code class="cpp">/*power function is not changed*/
int main ()
{
  int64_t sum = -1;
  for (unsigned i=0; i&lt;=0x80000000U-8; i += 8)
  {
    sum+=power(i+0, 0); sum+=power(i+1,1);
    sum+=power(i+2, 2); sum+=power(i+3,3);
    sum+=power(i+4, 4); sum+=power(i+5,5);
    sum+=power(i+6, 6); sum+=power(i+7,7);
  }
  printf ("sum = %ld\n", sum);
}</code></pre>
            <pre style="font-size: 0.7em;" class="console"><span>$ gcc -std=c99 -Wall -O3 flags-tuned.c -o flags-tuned
$ time ./flags-tuned
sum = 288231861405089791
real  0m1.286s</span></pre>
            <b>Speedup is ~5.5x.</b>
          </section>

        </section>
        <section>

          <section>
            <h2>Detailed analysis</h2>
            <p>This is how the compiler sees the outer loop<br> after inner loop inlining</p>
            <pre style="font-size: 0.7em;" ><code class="cpp">int64_t sum = -1;
for (unsigned i=0; i&lt;=0x80000000U-8; i += 8)
{
  int d = (int)i;
  sum+=1;
  sum+=(1+d);
  sum+=(2+d)*(2+d);
  sum+=(3+d)*(3+d)*(3+d);
  sum+=(4+d)*(4+d)*(4+d)*(4+d);
  sum+=(5+d)*(5+d)*(5+d)*(5+d)*(5+d);
  sum+=(6+d)*(6+d)*(6+d)*(6+d)*(6+d)*(6+d);
  sum+=(7+d)*(7+d)*(7+d)*(7+d)*(7+d)*(7+d)*(7+d);
}</code></pre>
          </section>

          <section>
            <h2>5 loop counters instead of 1</h2>
            <pre style="font-size: 0.7em;" ><code class="x86asm" style="max-height: 720px;">  movl  $6, %r11d
  movl  $5, %r10d
  movl  $4, %ebx
  movl  $3, %r9d
  movl  $2, %r8d
  movq  $-1, %rax // &lt;-accumulator
.L3:
  // loop body
  addl  $8, %r8d
  addl  $8, %r9d
  addl  $8, %ebx
  addl  $8, %r10d
  addl  $8, %r11d
  cmpl  $-2147483646, %r8d
  jne .L3</code></pre>
          </section>

          <section>
            <h2>(i+1), (i+2), (i+3)</h2>
            <pre style="font-size: 0.7em;" ><code class="x86asm" style="max-height: 720px;">leal  -1(%r8), %edx      // 2+i-1
movslq  %edx, %rdx       // to long
leaq  1(%rax,%rdx), %rdi // sum += 1+i

movl  %r8d, %edx         // 2+i
imull %r8d, %edx         // (2+i)**2
movslq  %edx, %rdx       // to long
leaq  (%rdx,%rdi), %rsi  // sum += (2+i)**2

movl  %r9d, %ecx
imull %r9d, %ecx
imull %r9d, %ecx
movslq  %ecx, %rcx
leaq  (%rcx,%rsi), %rdx</code></pre>
          </section>

          <section>
            <h2>(i+4), (i+5), (i+6)</h2>
            <pre style="font-size: 0.7em;" ><code class="x86asm" style="max-height: 720px;">movl  %ebx, %eax
imull %ebx, %eax
imull %eax, %eax
cltq
leaq  (%rax,%rdx), %rcx
movl  %r10d, %eax
imull %r10d, %eax
imull %eax, %eax
imull %r10d, %eax
cltq
addq  %rcx, %rax
movl  %r11d, %edx
imull %r11d, %edx
imull %r11d, %edx
imull %edx, %edx
movslq  %edx, %rdx
addq  %rdx, %rax</code></pre>
          </section>

          <section>
            <h2>(i+7)</h2>
            <pre style="font-size: 0.7em;" ><code class="x86asm" style="max-height: 720px;">  leal  5(%r8), %esi
  movl  $7, %ecx
  movl  $1, %edx
.L2:
  imull %esi, %edx
  subl  $1, %ecx
  jne .L2
  movslq  %edx, %rdx
  addq  %rdx, %rax</code></pre>
          <a href="https://gist.github.com/cuda-geek/026a22b4390e4a648bbc#file-case-study-power-1-7-s">Full listing is available in gitHub</a>
          </section>
        </section>

        <section>
        <section>
          <h2>Summary</h2>
            <ul style="width: 100%">
              <li>Copy propagation and other basic transformations enables more complicated ones</li>
              <li>Hoisting loop-invariant code and other ways of strength reduction techniques minimizes number of operations</li>
              <li>Compiler is very conservative to hoist floating point math</li>
              <li>Scalarization and loop unswitching makes loop bodies plane</li>
              <li>Loop peeling compiler capabilities are steel pure, use sentinels technique to eliminate extra checks
              and control flow</li>
              <li>Most hand-written pointer optimizations do not make sense with usage of optimization levels higher than O0</li>
            </ul>
        </section>
        <section>
          <h2>Summary</h2>
            <ul style="width: 100%">
              <li><code>__restrict</code> and <code>__builtin_assume_aligned</code> keywords only eliminate some loop
              versioning, but are not very useful from the performance perspective nowadays</li>
              <li>Functional body inlining is essential for loop further loop optimization</li>
              <li>Compiler will detect <code>memcpy</code> and <code>memset</code>, even if you implement them manually
              and call library function instead. Library functions are usually more efficient</li>
              <li>Use knowledge about semantics of your code to help a compiler optimize it</li>
            </ul>
        </section>
        </section>

        <section>
          <h1>THE END</h1>
          <img alt="The end" class="simple" src="images/popt/infinity.png">
          <h4><a href="https://github.com/cuda-geek">Marina Kolpakova</a> / 2015-2016</h4>
        </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: false,
                slideNumber: true,

                // parallaxBackgroundImage: "https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg",
                // parallaxBackgroundSize: "2100px 900px",
                // parallaxBackgroundHorizontal: 200,
                // parallaxBackgroundVertical: 50,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js' , async: true  },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
